
[TOC]

## 1.单一职责原则 - what

Single Responsibility Principle | SRP

A class or module shoule have a single responsibility.

一个类或者模块只负责完成一个职责（或功能）。

类和模块的理解方式：

1. 把模块看做比类更加抽象的概念，类也可以看做模块。
2. 把模块看做比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

不要设计大而全的类，要设计粒度小、功能单一的类。



## 2.单一职责原则 - how

大部分情况下，类里的方法，是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。

不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。

评价一个类的职责是否足够单一，并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，**可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越大，代码越来越多，这时，就可以将这个粗粒度的类，拆分成几个耕细粒度的类。这就是所谓的持续重构。**

几条判断原则，比起主观地去思考类是否职责单一，更有指导意义、更具有可执行性：

- 类中代码行数、函数或属性过多
  - 会影响代码的可读性和可维护性，需要考虑对类进行拆分
- 类依赖的其他类过多，或者依赖类的其他类过多
  - 不符合高内聚、低耦合的设计思想，需要对类进行拆分
- 私有方法过多
  - 需要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，提高代码的复用性
- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词来命名，说明类的职责定义可能不够清晰
- 类中大量的方法都是集中操作类中的某几个属性，可以考虑将这几个属性和对应的属性和方法拆分出来

一个凑合能用、比较宽泛的、可量化的标准（给业余选手准备的）：一个类的代码最好不超过200行，函数个数及属性个数最好都不要超过10个。

从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数半天找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）时，说明类的行数、函数、属性过多了，依赖“专业第六感”。



## 3.类的职责是否设计的越单一越好？

不是把类拆的越细越好，可能导致类的内聚性降低。

不管是应用**设计原则**还是**设计模式**，最终目的都是**提高代码的可读性、可扩展性、复用性、可维护性**等。

考虑应用某一个设计原则是否合理时，可以以此为**最终的考量标准**。



## 4.总结

### 4.1理解单一职责原则

一个类只负责完成一个职责或者功能。

不要设计大而全的类，要设计力度小、功能单一的类。

单一职责原则是为了实现**代码高内聚、低耦合**，提高代码的**复用性、可读性、可维护性**。

### 4.2判断类的职责是否足够单一

不同应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能有不同的判定结果。

侧面的判断指标：

- 类中的代码行数、函数或者属性过多
- 类依赖的其他类过多，或者依赖类的其他类过多
- 私有方法过多
- 比较难给类起一个合适的名字
- 类中大量的方法都是集中操作类中的某几个属性

### 4.3类的职责是否设计得越单一越好？

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的**内聚性**。

类职责单一，类依赖的和被依赖的其他类也会变少，减少胆码的**耦合性**，以此来实现代码的**高内聚、低耦合**。

但是，如果拆分得过细，实际上会适得其反，反倒会降低**内聚性**，也会影响代码的**可维护性**。









[TOC]

## 1.基于贫血模型的传统开发模式

### 1. 贫血模型

基于贫血模型的 MVC 三层架构开发模式，虽然已经成为标准的 Web 项目开发模式，但却违反了面向对象编程风格，是一种彻彻底底的面向过程编程风格，因此被有些人称为**反模式（anti-pattern）**。

### 2. 传统开发模式

MVC 三层架构，Model - View - Controller，展示层、逻辑层、数据层。
前后端分离项目，Repository 层 - Service 层 - Controller 层。
- 数据访问 
  - Repository + Entity
- 业务逻辑 
  - Service + BO（Business Object）
- 暴露接口
  - Controller + VO（View Object）

只包含数据，不包含业务逻辑的类，就叫做**贫血模型（Anemic Domain Model）**。
贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编码风格。


## 2.基于充血模型的 DDD 开发模式

### 1. 充血模型

充血模型（Rich Domain Model）与贫血模型正好相反，数据和对应的业务逻辑被封装到同一个类中。满足面向对象的封装特性，是典型的面向对象编程风格。

### 2. DDD 开发模式

领域驱动设计（Domain Driven Design，DDD），主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域驱动模型及其交互。

除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另一个更加重要的工作：针对公司的业务，合理地做微服务拆分，领域驱动设计恰好是用来指导划分服务的。所以，微服务加速了领域驱动设计的盛行。

做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。所以不要把领域驱动设计当银弹，不要花太多时间去过度地研究它。

基于充血模型的 DDD 开发模式与基于贫血模型的传统开发模式的区别，主要在 Service 层。

在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，**既包含数据，也包含业务逻辑**。而 Service 类变得非常单薄。
总结一下的话就是，基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain。


## 3.为什么基于贫血模型的传统开发模式如此受欢迎？

基于贫血模型的传统开发模式，将数据与业务逻辑分离，违反了 OOP 的封装特性，实际上是一种面向过程的编程风格。但是，现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。

面向过程编程风格有种种弊端，比如，数据和操作分离之后，数据本身的操作就不受限制了。任何代码都可以随意修改数据。

既然基于贫血模型的这种传统开发模式是面向过程编程风格的，那它又为什么会被广大程序员所接受呢？

1. 大部分情况下，业务系统可能比较简单，简单到就是基于 SQL 的 CRUD 操作，所以根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。此外，业务简单到即使使用充血模型，模型本身包含的业务逻辑也不会很多，设计出来的领域模型业务也会比较单薄，跟贫血模型差不多，没有太大意义。
2. 充血模型的设计比贫血模型更加有难度。
3. 思维已固化，转型有成本。基于贫血模型的开发模式经历了这么多年，已经深入人心，习以为常。使用基于充血模型和 DDD 会有学习成本、转型成本，很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的。


## 4.什么项目应该考虑使用基于充血模型的 DDD 开发模式？

- 基于贫血模型的传统的开发模式，比较适合**业务比较简单**的系统开发。
- 相对应的，基于充血模型的 DDD 开发模式，更适合**业务复杂**的系统开发。比如，**包含各种利息计算模型、还款模型等复杂业务**的金融系统。


## 5.开发模式决定开发流程

基于充血模型的 DDD 开发模式的开发流程，在应对复杂业务系统的开发时更加有优势。

1. 不夸张的讲，平时的开发，大部分都是基于 SQL 驱动（SQL-Driven）的开发模式。
  - 我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。
  - 业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致**各种长得差不多、区别很小的 SQL 语句满天飞**。
  - 所以，在这个过程中，很少有人会应用领域模型、OOP 的概念，也很少有代码复用意识。对于简单业务系统来说，这种开发方式问题不大。但**对于复杂业务系统的开发来说，这样的开发方式会让代码越来越混乱，最终导致无法维护**。
2. 如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。
  - 在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。**领域模型相当于可复用的业务中间层**。**新功能需求的开发，都基于之前定义好的这些领域模型来完成**。
  - 我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，来**提高代码的复用性和可维护性**，所以它更加适合这种复杂系统的开发。

## 6.保证数据一致性的方法

1. 依赖数据库事务的原子性，将两个操作放在同一个事务中执行
  - 但这样不够灵活，如果做了分库分表，数据存储在不同的库中，无法直接利用数据库本身的事务特性
2. 支持分布式事务的开源框架
  - 为了保证数据的强一致性，实现逻辑一般比较复杂、本身性能也不高，会影响业务的执行时间
3. 不保证数据的强一致性，只实现数据的最终一致性

## 7.Service 类主要职责


在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 来变得很薄，但在代码设计与实现中，并没有完全将 Service 类去掉，为什么？Service 类在这种情况下担当的职责是什么？哪些功能逻辑放到 Service 类中？

区别于 Domain 的职责，Service 类主要职责：

1. Service 类负责与 Repository 交流。
  - 之所以使用 Service 类与 Repository 打交道，而不是让 Domain 与 Repository 打交道，是因为保持领域模型的独立性
    - 不与任何其它层代码（Repository 层）或开发框架（如 Spring、MyBatis）耦合在一起
    - 将流程性的代码逻辑（如从 DB 中获取数据、映射数据）与领域模型的业务逻辑解耦
    - 让领域模型更加可复用
2. Service 类负责跨领域模型的业务聚合功能。
3. Service 类负责一些非功能性、与三方系统交互的工作。
  - 如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等

## 8.Controller 层与 Repository 层

在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？

答案是没有必要。

- Controller 层主要负责接口的暴露
- Repository 层主要负责与数据库打交道
- 这两层包含的业务逻辑并不多，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

如何控制面向过程编程风格的副作用？

- Repository 的 Entity，即使被设计成贫血模式，违反了面向对象编程的封装特性，有被任意代码修改数据的风险，但是 Entiry 的生命周期是有限的。
  - 一般来讲，把 Entity 传递到 Service 层后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。
  - Entity 生命周期到此结束，所以也并不会被到处任意修改。
- Controller 层的 VO，实际上是一种 DTO（Data Transfer Object，数据传输对象）
  - 主要是作为接口的数据传输承载体，将数据发送给其他系统。
  - 从功能上来讲，VO 理应不包含业务逻辑、只包含数据。
  - 所以，将 VO 设计成贫血模型也是比较合理的。




[TOC]

JVM 问题分析调优经验
1. 高分配速录（High Allocation Rate）
   - 分配速率，表示单位时间内分配的内存量；
   - 通常使用 MB/sec 作为单位；
   - 上次垃圾收集后，与下一次GC 开始之前的年轻代使用量，两者的差值除以时间；
   - new 出来的对象，在 Eden 区；
   - Eden 区大小，蓄水池效应，影响Minor GC 的次数和时间，进而应吸纳过吞吐量；
   - 只要增加年轻代大小，即可降低分配速率过高所造成的影响；
   - 增加年轻代空间并不会降低分配速率，但是会减少 GC 的频率；

2. 过早提升（Premature Promotion）
   - 提升速率 promotion rate，用于衡量单位时间从年轻代提升到老年代的数据量。
   - Major GC 不是为频繁回收而设计的，如果部分对象过早提升，就需要 Major GC 清理这些生命短暂的对象，导致 GC 暂停时间过长，严重影响系统吞吐量。
   - 年轻代减少量减去整个堆内存减少量，就是提升量，除以耗时，即为提升速率。
   - 症状：
     - 短时间内频繁执行 Full GC；
     - 每次 Full GC 后，老年代使用率都很低，在 10%~20%或以下；
     - 提升速率接近于分配速率；
   - 演示：
     - -Xmx24m -XX:NewSize=16m -XX:MaxTenuringThreshold=1
     - java -Xmx256m -XX:NewSize=192m -XX:MaxTenuringThreshold=1 -XX:+PrintGC -XX:+PrintGCDateStamps GcAnalysis
   - 解决方法：（让临时数据能够在年轻代放得下）
     - 增加年轻代大小；
     - 减少每次批处理的数量；

GC 疑难情况问题分析
1. 查询业务日志
   1. 请求压力过大、波峰、遭遇降级、熔断等，基础服务，外部 API 依赖；
2. 查看系统资源和监控信息
   1. 硬件信息、操作系统平台、系统架构；
   2. 排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞争等；
   3. 排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、超时、连接数；
3. 查看性能指标
   1. 实时监控、历史数据；
   2. 发现假死、卡顿、响应变慢等现象；
   3. 排查数据库
      1. 并发连接数（20~50较好）、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询数据量、redo 日志、undo 日志、binlog 日志、代理、工具 BUG等；
      2. 考虑优化包括：集群、主备、只读实例、分片、分区；
   4. 大数据，中间件，JVM 参数；
4. 排查系统日志
   1. 重启、崩溃、kill
5. APM
   1. 发现有些链路请求变慢等；
6. 排查应用系统
   1. 配置文件
      1. 启动参数配置、Spring 配置、JVM 监控参数、数据库参数、log 参数（异步批量（条数、大小）打印日志、轮换）、APM 配置、内存问题
      2. 比如：是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC 问题等；
   2. GC 问题
      1. GC 算法、GC 的 KPI，GC 总耗时，GC 最大暂停时间，分析GC 日志和监控指标；
      2. 内存分配速率、分代提升速率、内存使用率等；适当修改内存配置；
   3. 排查线程
      1. 理解线程状态、并发线程数、线程 dump、锁资源、锁等待、死锁等；
   4. 排查代码
      1. 安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方库、XSS、CORS、正则；
   5. 单元测试
      1. 覆盖率、边界值、Mock 测试、集成测试；
7. 排除资源竞争、坏邻居效应
8. 疑难问题排查分析手段
   1. dump 线程\内存；
   2. 抽样分析\调整代码、异步化、削峰填谷；

在低版本默认采用并行GC 是很好的选择。



